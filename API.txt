API

Processo da Requisição
1 Fetch - Busca de dados em um Endpoint
2 Routes - A requisição chega no arquivo de rotas e é direcionada para o controlador certo
3 Controller - Aqui ocorre a tratação da requisição, verificação dos dados informados e resposta do servidor de acordo com os resultados obtidos
4 Model - Recebe os dados ja extraidos da requisição, monta a instrução sql e executa a query por meio da função executar em Database.executar(instrucao)

Processo de retorno 
1 Model - Retorna a resolução da query do banco de dados
2 Controller - Recebe o return do Model e verifica se deu tudo certo ou não. De acordo com o resultado ele defini o erro que vai ser retornado ou se vai ser retornado o valor que veio de model (Normalmente as tuplas que a query modificou/inseriu/selecionou)
3 Routes - Este só repassa a informação. É como se ela passasse direto por ele. Uma vez o res sendo usado no controller; a resposta (res) já é enviada através do router também.
4 Fetch - A função fetch executa seu trecho "then()", onde a resposta (res) é recebida e tradada da forma que o usuário quiser.


Processo para Implementar funcionalidade na API
Criar funções e exportá-las no final do arquivo (fetch, routes, controller, model)

1 Crie funções com nomes pensados no objetivo que você precisa atingir, dessa forma você não se perde no meio do caminho.
2 Tente sempre copiar ou imitar o código que já funciona e só adaptar ao seu propósito (Ctrl+C - Ctrl+V e um pouco de criatividade).
3 Tenha em mente que oque vai ser retornado de Model vai ser uma vetor ( [] ) com as tuplas dentro em forma de JSON separadas por virgulas (as famosas posições). por exemplo um retorno cheio de tuplas seria algo como [ {nome: "yan1"} , {nome: "yan2"},{nome: "yan3"},{nome: "yan4"},{nome: "yan5"}] e para acessar o valor yan3 é preciso fazer [2].nome e supondo que variavel se chame row. seria assim: row[2].nome ("yan3"). Num sistema de login, o certo é retornar uma tupla só, ou seja row[0] != undefined. Se a posição 0 não tiver valor quer dizer que os dados informados não bateram com nenhuma tupla da tabela, e se houver mais posições que 1 (row.length > 1) quer dizer que há masi de um registro com aquela informação (mesmo email e senha pra mais de um cadastro).
4 Tenha certeza que seu fetch está puxando o endereço certo e que as configurações estejam definidas corretamente, no caso a configuração é o segundo parâmetro da função, vou deixar aqui de exemplo:
Este é para o método POST (Aquele em que você informa algum dado ao servidor)
{
            method: "POST",
            headers: {
                "Content-Type": "application/json"
            },
            body: JSON.stringify({
               **aqui vai seu json***
            })
        }

Este é para o método GET (Aquele onde você só solicita dados do servidor, NÃO PODE ter body)
{
            method: "GET",
            headers: {
                "Content-Type": "application/json"
            }
        }

5 É PRIMORDIAL/ESSENCIAL/DEVIDO/OBRIGATÓRIO que seu router esteja defindo para o meétodo certo, para post: router.post(a,b) e para get: router.get(a,b)